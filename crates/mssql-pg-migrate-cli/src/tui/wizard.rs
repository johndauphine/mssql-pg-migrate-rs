//! Configuration wizard for the TUI.
//!
//! Provides a step-by-step interactive configuration builder similar to the Go implementation.

use std::path::PathBuf;

/// Wizard step enumeration.
#[derive(Debug, Clone, Copy, PartialEq, Default)]
pub enum WizardStep {
    #[default]
    SourceHost,
    SourcePort,
    SourceDatabase,
    SourceUser,
    SourcePassword,
    TargetHost,
    TargetPort,
    TargetDatabase,
    TargetUser,
    TargetPassword,
    TargetMode,
    Workers,
    OutputFile,
    Confirm,
    Done,
}

impl WizardStep {
    /// Advance to the next step.
    pub fn next(self) -> Self {
        match self {
            Self::SourceHost => Self::SourcePort,
            Self::SourcePort => Self::SourceDatabase,
            Self::SourceDatabase => Self::SourceUser,
            Self::SourceUser => Self::SourcePassword,
            Self::SourcePassword => Self::TargetHost,
            Self::TargetHost => Self::TargetPort,
            Self::TargetPort => Self::TargetDatabase,
            Self::TargetDatabase => Self::TargetUser,
            Self::TargetUser => Self::TargetPassword,
            Self::TargetPassword => Self::TargetMode,
            Self::TargetMode => Self::Workers,
            Self::Workers => Self::OutputFile,
            Self::OutputFile => Self::Confirm,
            Self::Confirm => Self::Done,
            Self::Done => Self::Done,
        }
    }

    /// Go back to the previous step.
    pub fn prev(self) -> Self {
        match self {
            Self::SourceHost => Self::SourceHost,
            Self::SourcePort => Self::SourceHost,
            Self::SourceDatabase => Self::SourcePort,
            Self::SourceUser => Self::SourceDatabase,
            Self::SourcePassword => Self::SourceUser,
            Self::TargetHost => Self::SourcePassword,
            Self::TargetPort => Self::TargetHost,
            Self::TargetDatabase => Self::TargetPort,
            Self::TargetUser => Self::TargetDatabase,
            Self::TargetPassword => Self::TargetUser,
            Self::TargetMode => Self::TargetPassword,
            Self::Workers => Self::TargetMode,
            Self::OutputFile => Self::Workers,
            Self::Confirm => Self::OutputFile,
            Self::Done => Self::Confirm,
        }
    }

    /// Check if this step requires password input (masked).
    pub fn is_password(&self) -> bool {
        matches!(self, Self::SourcePassword | Self::TargetPassword)
    }

    /// Get the step number (1-indexed).
    pub fn step_number(&self) -> usize {
        match self {
            Self::SourceHost => 1,
            Self::SourcePort => 2,
            Self::SourceDatabase => 3,
            Self::SourceUser => 4,
            Self::SourcePassword => 5,
            Self::TargetHost => 6,
            Self::TargetPort => 7,
            Self::TargetDatabase => 8,
            Self::TargetUser => 9,
            Self::TargetPassword => 10,
            Self::TargetMode => 11,
            Self::Workers => 12,
            Self::OutputFile => 13,
            Self::Confirm => 14,
            Self::Done => 14,
        }
    }

    /// Get the total number of steps.
    pub fn total_steps() -> usize {
        14
    }
}

/// Configuration being built by the wizard.
#[derive(Debug, Clone, Default)]
pub struct WizardConfig {
    pub source_host: String,
    pub source_port: u16,
    pub source_database: String,
    pub source_user: String,
    pub source_password: String,
    pub target_host: String,
    pub target_port: u16,
    pub target_database: String,
    pub target_user: String,
    pub target_password: String,
    pub target_mode: String,
    pub workers: usize,
}

impl WizardConfig {
    /// Create a new config with defaults.
    pub fn new() -> Self {
        Self {
            source_host: "localhost".to_string(),
            source_port: 1433,
            source_database: String::new(),
            source_user: String::new(),
            source_password: String::new(),
            target_host: "localhost".to_string(),
            target_port: 5432,
            target_database: String::new(),
            target_user: String::new(),
            target_password: String::new(),
            target_mode: "drop_recreate".to_string(),
            workers: 4,
        }
    }

    /// Generate YAML configuration string.
    pub fn to_yaml(&self) -> String {
        format!(
            r#"# Generated by mssql-pg-migrate wizard
source:
  type: mssql
  host: {}
  port: {}
  database: {}
  user: {}
  password: {}

target:
  type: postgres
  host: {}
  port: {}
  database: {}
  user: {}
  password: {}

migration:
  target_mode: {}
  workers: {}
"#,
            self.source_host,
            self.source_port,
            self.source_database,
            self.source_user,
            self.source_password,
            self.target_host,
            self.target_port,
            self.target_database,
            self.target_user,
            self.target_password,
            self.target_mode,
            self.workers,
        )
    }
}

/// Wizard state.
#[derive(Debug, Clone)]
pub struct WizardState {
    /// Current step.
    pub step: WizardStep,

    /// Configuration being built.
    pub config: WizardConfig,

    /// Output file path.
    pub output_path: PathBuf,

    /// Transcript of previous answers.
    pub transcript: Vec<String>,

    /// Current input value.
    pub input: String,

    /// Error message to display.
    pub error: Option<String>,
}

impl WizardState {
    /// Create a new wizard state.
    pub fn new(output_path: PathBuf) -> Self {
        Self {
            step: WizardStep::default(),
            config: WizardConfig::new(),
            output_path,
            transcript: Vec::new(),
            input: String::new(),
            error: None,
        }
    }

    /// Get the prompt for the current step.
    pub fn get_prompt(&self) -> String {
        let step_info = format!("[{}/{}] ", self.step.step_number(), WizardStep::total_steps());
        match self.step {
            WizardStep::SourceHost => format!(
                "{}Source SQL Server Host [{}]: ",
                step_info, self.config.source_host
            ),
            WizardStep::SourcePort => format!(
                "{}Source Port [{}]: ",
                step_info, self.config.source_port
            ),
            WizardStep::SourceDatabase => format!("{}Source Database: ", step_info),
            WizardStep::SourceUser => format!("{}Source User: ", step_info),
            WizardStep::SourcePassword => format!("{}Source Password: ", step_info),
            WizardStep::TargetHost => format!(
                "{}Target PostgreSQL Host [{}]: ",
                step_info, self.config.target_host
            ),
            WizardStep::TargetPort => format!(
                "{}Target Port [{}]: ",
                step_info, self.config.target_port
            ),
            WizardStep::TargetDatabase => format!("{}Target Database: ", step_info),
            WizardStep::TargetUser => format!("{}Target User: ", step_info),
            WizardStep::TargetPassword => format!("{}Target Password: ", step_info),
            WizardStep::TargetMode => format!(
                "{}Target Mode (drop_recreate/truncate/upsert) [{}]: ",
                step_info, self.config.target_mode
            ),
            WizardStep::Workers => format!(
                "{}Number of Workers [{}]: ",
                step_info, self.config.workers
            ),
            WizardStep::OutputFile => format!(
                "{}Output File [{}]: ",
                step_info,
                self.output_path.display()
            ),
            WizardStep::Confirm => "Save configuration? (y/n): ".to_string(),
            WizardStep::Done => String::new(),
        }
    }

    /// Process input for the current step.
    pub fn process_input(&mut self) -> Result<bool, String> {
        let input = self.input.trim().to_string();
        self.error = None;

        match self.step {
            WizardStep::SourceHost => {
                if !input.is_empty() {
                    self.config.source_host = input.clone();
                }
                self.transcript.push(format!("Source Host: {}", self.config.source_host));
            }
            WizardStep::SourcePort => {
                if !input.is_empty() {
                    self.config.source_port = input
                        .parse()
                        .map_err(|_| "Invalid port number".to_string())?;
                }
                self.transcript.push(format!("Source Port: {}", self.config.source_port));
            }
            WizardStep::SourceDatabase => {
                if input.is_empty() {
                    return Err("Database name is required".to_string());
                }
                self.config.source_database = input.clone();
                self.transcript.push(format!("Source Database: {}", input));
            }
            WizardStep::SourceUser => {
                if input.is_empty() {
                    return Err("Username is required".to_string());
                }
                self.config.source_user = input.clone();
                self.transcript.push(format!("Source User: {}", input));
            }
            WizardStep::SourcePassword => {
                self.config.source_password = input;
                self.transcript.push("Source Password: ********".to_string());
            }
            WizardStep::TargetHost => {
                if !input.is_empty() {
                    self.config.target_host = input.clone();
                }
                self.transcript.push(format!("Target Host: {}", self.config.target_host));
            }
            WizardStep::TargetPort => {
                if !input.is_empty() {
                    self.config.target_port = input
                        .parse()
                        .map_err(|_| "Invalid port number".to_string())?;
                }
                self.transcript.push(format!("Target Port: {}", self.config.target_port));
            }
            WizardStep::TargetDatabase => {
                if input.is_empty() {
                    return Err("Database name is required".to_string());
                }
                self.config.target_database = input.clone();
                self.transcript.push(format!("Target Database: {}", input));
            }
            WizardStep::TargetUser => {
                if input.is_empty() {
                    return Err("Username is required".to_string());
                }
                self.config.target_user = input.clone();
                self.transcript.push(format!("Target User: {}", input));
            }
            WizardStep::TargetPassword => {
                self.config.target_password = input;
                self.transcript.push("Target Password: ********".to_string());
            }
            WizardStep::TargetMode => {
                if !input.is_empty() {
                    let mode = input.to_lowercase().replace("-", "_").replace(" ", "_");
                    if mode == "drop_recreate" || mode == "truncate" || mode == "upsert" {
                        self.config.target_mode = mode;
                    } else {
                        return Err("Invalid mode. Use drop_recreate, truncate, or upsert".to_string());
                    }
                }
                self.transcript.push(format!("Target Mode: {}", self.config.target_mode));
            }
            WizardStep::Workers => {
                if !input.is_empty() {
                    self.config.workers = input
                        .parse()
                        .map_err(|_| "Invalid number".to_string())?;
                    if self.config.workers == 0 {
                        return Err("Workers must be at least 1".to_string());
                    }
                }
                self.transcript.push(format!("Workers: {}", self.config.workers));
            }
            WizardStep::OutputFile => {
                if !input.is_empty() {
                    self.output_path = PathBuf::from(&input);
                }
                self.transcript.push(format!("Output: {}", self.output_path.display()));
            }
            WizardStep::Confirm => {
                let confirmed = input.to_lowercase() == "y" || input.to_lowercase() == "yes";
                if confirmed {
                    // Save configuration
                    if let Err(e) = self.save() {
                        return Err(format!("Failed to save: {}", e));
                    }
                    self.transcript.push(format!("Configuration saved to {}", self.output_path.display()));
                } else {
                    self.transcript.push("Configuration cancelled.".to_string());
                }
                self.step = WizardStep::Done;
                self.input.clear();
                return Ok(true); // Wizard complete
            }
            WizardStep::Done => {
                return Ok(true);
            }
        }

        // Advance to next step
        self.step = self.step.next();
        self.input.clear();
        Ok(false)
    }

    /// Save the configuration to file.
    fn save(&self) -> std::io::Result<()> {
        std::fs::write(&self.output_path, self.config.to_yaml())
    }

    /// Check if the wizard is complete.
    pub fn is_done(&self) -> bool {
        self.step == WizardStep::Done
    }
}
